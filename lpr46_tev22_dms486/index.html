<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>PICcompose!</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">

  <!-- Favicons -->
  <link href="img/notes.png" rel="icon">

  <!-- Bootstrap CSS File -->
  <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Libraries CSS Files -->
  <link href="lib/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="lib/animate/animate.min.css" rel="stylesheet">
  <link href="lib/ionicons/css/ionicons.min.css" rel="stylesheet">
  <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">
  <link href="lib/lightbox/css/lightbox.min.css" rel="stylesheet">

  <!-- Main Stylesheet File -->
  <link href="css/style.css" rel="stylesheet">

  <!--style things?? i don't know css-->
  <style>
      p {
        text-align: justify;
      }
      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
      }
      iframe {
        display: block;
        width: 800px;
        height: 400px;
        margin: 0 auto;
        border: 0;
      }
      iframe {
        display: block;
        text-align: left;
      }
      code {
        color: #be0b0b;
      }
  </style>
  <!-- =======================================================
    Theme Name: DevFolio
    Theme URL: https://bootstrapmade.com/devfolio-bootstrap-portfolio-html-template/
    Author: BootstrapMade.com
    License: https://bootstrapmade.com/license/
  ======================================================= -->
</head>

<body id="page-top">

  <!--/ Nav Star /-->
  <nav class="navbar navbar-b navbar-trans navbar-expand-md fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll" href="#page-top">PICcompose</a>
      <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarDefault"
        aria-controls="navbarDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
      </button>
      <div class="navbar-collapse collapse justify-content-end" id="navbarDefault">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#About">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#HLD">High Level Design</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#Hardware">Hardware</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#Software">Software</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#Results">Results</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#Conclusions">Conclusions</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#Appendix">Appendix</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <!--/ Nav End /-->

  <!--/ Intro Skew Start /-->
  <div id="home" class="intro route bg-image" style="background-image: url(img/box.jpg)">
    <div class="overlay-itro"></div>
    <div class="intro-content display-table">
      <div class="table-cell">
        <div class="container">
          <br>
          <!--<p class="display-6 color-d">Hello, world!</p>-->
          <h1 class="intro-title mb-4"><br>PICcompose<br></h1>
          <p class="intro-subtitle"><span class="text-slider-items">Composition Assistant, End-to-end Music Annotator, Metronome and Tuner,ECE 4760 Final Project</span><strong class="text-slider"></strong></p>
          <!-- <p class="pt-3"><a class="btn btn-primary btn js-scroll px-4" href="#about" role="button">Learn More</a></p> -->
        </div>
      </div>
    </div>
  </div>
  <!--/ Intro Skew End /-->

  <!--/ About Start /-->
  <section id="About" class="about-mf sect-pt4 route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="box-shadow-full" style="vertical-align: middle;">
            <div class="row" >
              <div class="col-md-6" >
                <div class="row" >
                  <img class="about-img" src="img/flute.jpg" class="img-fluid rounded b-shadow-a" alt="Diane playing the flute">
                  
                  <img class="about-img" src="img/music.jpg" class="img-fluid rounded b-shadow-a" alt="Twinkle Twinkle Little Star">
                  
                </div>
              </div>
              <div class="col-md-6">
                <div class="about-me pt-4 pt-md-0">
                    <h5 class="title-left">
                      About PICcompose
                    </h5>
                    <h5>
                        <br>An ECE 4760 Project by: <br><br>
                        <b>Diane Sutyak</b> (dms486)  <br>
                        <b>Tara van Nieuwstadt</b> (tev22) <br>
                        <b>Laasya Renganathan</b> (lpr46) <br>
                    </h5>
                  <p class="lead">
                    <strong style="color:#be0b0b">PICcompose</strong> is a tool that converts raw audio data into an editable music score! 
                    </p>
                  <p class="lead">
                    Over the course of this project, we built a PIC32-driven solution to facilitate the music composition process.
                    We extracted frequencies from an audio source and converted them to the correct note in the MIDI format. 
                    We then figured out note timings and sent the data to an external computer, which compiled the data into an actual MIDI file, saved it, and loaded it into MuseScore, our group's favorite (free) music editing software!
                    At the end of the project, we had a nicely packaged product that demonstrated our ability to notate simple melodies with 100% accuracy!  
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ About End /-->

  <!--/ High Level Design /-->
  <section id="HLD" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              High Level Design
            </h3>
            <p class="subtitle-a">
              An overview of our project.
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                <!--/ Rationale /-->
                <h3 >Project Rationale </h3>
                <p class="lead">
                    The three of us are musicians, and we know that composing music can be a time consuming task. It can be almost as difficult to notate the melodies as it is to find inspiration for them. 
                    When brainstorming ideas for tunes, oftentimes a composer will try it out on their instrument of choice, make notes, 
                    and then translate their thoughts into a music score editing software of their choice to generate the sheet music. 
                    The goal of our project was to eliminate the middleman in the music composition process by creating a tool to directly generate sheet music after playing an instrument.
                    A block diagram of our overall system is shown below.
                </p>
                <!--/ Background Math + MIDI explanation /-->    
                <h3 >  Technical Background  </h3>
                <p class="lead">
                  The core technical portions of our project were the math required for audio processing, and understanding the MIDI protocol.
                </p> 
                  <h5 >  Audio Input  </h5>
                    <p class="lead">
                      The raw audio input to PICcompose needed to be amplified. 
                      We chose to use a Sallen-Key filter due to its complex conjugate poles. 
                      The corner frequency, where frequencies are cut off, of a Sallen-Key filter is calculated as follows:
                      <br></p>
                      <img  src="img/freq_eqn.png"  alt="sallen key freq eqn">
                      <p class="text-center"> Sallen Key Corner Frequency Equation</p>
                      <p class="lead">
                      The Q value of a Sallen-Key is calculated as follows:<br></p>
                      <img  src="img/q_eqn.png"  alt="q value eqn">
                      <p class="text-center">Sallen Key Q Value Equation</p>
                    
                  <h5 >  Note Detection  </h5>
                    <p class="lead">
                        A fast Fourier transform (FFT) is used to determine the frequency of the input note. 
                        A Fourier transform converts a signal from the time domain to the frequency domain, 
                        and a discrete Fourier transform requires that an input time domain signal and the output frequency 
                        domain signal are both discrete. 
                        An FFT is an algorithm that can compute the DFT quickly. The DFT equation is shown below:
                    </p>
                    <img  src="img/dft.png"  alt="dft eqn">
                    <p class="text-center"> Discrete Fourier Transform Equation</p>
                    <p class="lead">
                      To take an FFT of continuous time audio data, the FFT algorithm first samples the data to generate the input signal, 
                      using the ADC on the microcontroller to get input from the microphone. 
                      It takes the real and imaginary components of the signal at discrete time intervals and outputs one pair of real and imaginary amplitude components corresponding to each sampled frequency. 
                      The output frequencies are evenly spaced from 0 to the Nyquist rate, which is half of the sampling rate. 
                      N samples taken at m Hz yields n/2 discrete frequencies starting at 0 and incrementing by 2m/n Hz for each “bin”. We chose to use an 8 kHz sampling rate with 1024 samples for the FFT, giving a frequency spacing of about 8Hz. 
                      We found the bin with the largest amplitude, and then used the bin spacing to convert this back to a real frequency and later to a MIDI note.
                    </p>
                  <h5 >  MIDI Overview  </h5>
                    <p class="lead">
                        MIDI (Musical Instrument Digital Interface) is an industry standard method to store song information. 
                        This project involves creating MIDI files, which we do by writing MIDI messages to a .mid file. 
                        Each main MIDI message is encoded into bytes of the following format.
                        <br><p class="text-center" style="font-size: x-large;">delta time | message_type | data</p><br>
                        <p class="lead">
                        Delta time is the time (in microseconds, or “ticks”) since the last message. The data will be two bytes long, and what those bytes mean 
                        corresponds to what the message type is. For our purposes, we are only using the <code>note_on</code> message, which looks like this:
                        </p><br><p class="text-center" style="font-size: x-large;">delta time | 0x90 | note_number | velocity</p><br>
                        <p class="lead">
                        Note number goes from 0 to 127 and corresponds to a note between A0 and G9. 
                        For context, a flute’s range is between B3 and C6, so MIDI fully encompasses the range of almost all instruments. 
                        The velocity value corresponds to volume; for our purposes, we will set this to a default intermediate value.
                        MIDI also supports meta-messages, which relate to the file at large. 
                        This includes tempo, key signature, file name, and other similar messages. 
                        They have a structure as follows:
                        </p><br><p class="text-center" style="font-size: x-large;">FF | meta_type | length | data</p><br>
                        <p class="lead">
                        The delta time in this case doesn’t matter. 
                        Since some of the data can be encoded with different numbers of bytes depending on the meta message type, 
                        a length field needs to be specified. 
                        For our project, we mainly use the <code>set_tempo</code> meta message, which appears like this:
                      </p><br><p class="text-center" style="font-size: x-large;">FF | 0x51 | 0x03 | TT | TT | TT</p><br><p class="lead">
                        The tempo needs to be encoded as ticks per quarter note. 
                        The default tempo is 120 BPM, or a MIDI tempo of 500000. 
                        MIDI has support for many other musical encodings, but these are the features we found useful to our project.
                    </p>
                
                <!--/ Logical Structure /--> 
                <h3 >  Logical Structure </h3> 
                <p class="lead">
                    A block diagram of our overall system's logical structure is shown below. Most of the processing was done on the PIC32 side.
                </p>
                <img width=80% height=80% src="img/block.png"  alt="block diagram">
                  <p class="text-center"> PICcompose Block Diagram</p>
                <!--/ HW/SW Tradeoffs /-->  
                <h3 >Hardware/Software Tradeoffs </h3>
                <p class="lead">
                    This project did come with some hardware-software tradeoffs. One major tradeoff involved the filtering. 
                    Only the low pass filter was implemented in pure hardware; low frequencies were actually cut off in software. 
                    We could have built a band pass filter in hardware, but figured the software implementation might be cleaner.
                    Additionally, we use a keypad as part of the user interface. 
                    With some more advanced TFT printing techniques, we may have been able to reduce the number of buttons/change how the tempo settings were done.
                    The keypad could have been swapped out for + and - buttons to increase/decrease tempo, which would have taken up less space visually.
                    However, we decided a keypad provided a little more user flexibility, and that TFT manipulation would have taken too much time to implement cleanly.
                </p>
                <!--/ relationship to other standards IEEE, ISO, ANSI, DIN , existing projects patents/trademarks /-->  
                <h3 >Relationship to IEEE Standards and Existing Products</h3>
                <p class="lead">
                    We believe that our project is fully compliant with IEEE and other standards. 
                    Our project is designed to be safe and user-friendly, and most of its electrical components are hidden inside the box. 
                    It is easy to use, with simple visual feedback and user controls. 
                    <br><br>
                    Surprisingly few automatic sheet music generators exist already. 
                    <a  href="https://www.lunaverus.com/">AnthemScore, </a>
                    <a  href="https://scorecloud.com/">ScoreCloud,  </a> and 
                    <a  href="https://melodyscanner.com/">Melody Scanner </a> are some major ones that exist, 
                    but they are paid products so we did not use any of their code when creating our project.
                    In addition, our project involves software-hardware co-design, rather than a pure software implementation that can be found in similar products.
                    We discuss this project in relation to our competitors in the <a class="js-scroll"  href="#Conclusions">Conclusions section</a> 
                  </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ High Level Design End /-->


  <!--/ Hardware Start /-->
  <section id="Hardware" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Hardware
            </h3>
            <p class="subtitle-a">
              The physical components of our system.
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                <h3>Hardware: Overview </h3>
                  <p class="lead">
                      The primary hardware components of this project are the microphone with its associated filtering and amplification circuitry, 
                      the keypad, a toggle switch and LED, the UART serial interface, and the TFT LCD.
                      The keypad connects directly to GPIO pins on the port expander to interface with the PIC32 microcontroller. 
                      The output of the microphone’s analog circuitry is read by an ADC pin on the PIC32. 
                      The toggle switch and LED also connect to GPIO pins, while the UART is connected to the UART receive and transmit pins of the board.
                      The TFT display, which was integral to the user interface aspect of the project, also connected directly to the board. 
                      Our final circuitry was soldered onto a solder board, and our hardware was packed into a clean box for the user.
                  </p> 
                  <h3 >Tuner: Microphone Amplification</h3>
                  
                  <p class="lead">
                      The first end of our system is the amplification and filtering done in hardware. 
                      Raw audio is picked up by an Adafruit electret microphone. 
                      The signal is then sent through a non-inverting op-amp with a gain of 50. </p>
                      <img style="height: 50%; width: 50%" src="img/sallenkey.png"  alt="A sallen key filter">
                      <p class="text-center"> The Microphone Circuit</p> 
                    <p class="lead">
                      A gain of 50 was chosen because it increases the microphone output signal amplitude from 15 mV to 750 mV, an amplitude usable by the PIC32’s ADC. 
                      After amplification, the signal is sent through an anti-aliasing Sallen-Key filter. 
                      The Sallen-Key filter was implemented to have a pole at 2.5 kHz, and Q of 1. We chose the frequency of 2.5 kHz because 
                      the FFT (done on the PIC32) sampled at 8 kHz, and 2.5 kHz corresponds to a note well out of the range of a flute. 
                      The output of the Sallen-Key filter is the input to the PIC32’s ADC. After prototyping on a normal breadboard, the circuit was ported over to the small solderboard.
                      Both op-amps used were powered by the PIC32 at 3.3V. The op-amp used was the MCP6242 because that model could be powered with voltages as low as 1.8 V. 
                  </p>
                      
                      <div class="row">
                          <div class="col-md-6">
                              <img  src="img/amp_out.png"  alt="amplifier signal out">
                              <p class="text-center"> The Amplifier Output Signal</p>
                          </div>
                          <div class="col-md-6">
                              <img style="height: 80%; width: 80%" src="img/amp_fft.png"  alt="amplifier fft out">
                              <p class="text-center"> The Amplifier Output FFT</p>
                          </div>
                      </div>
                      <div class="row">
                          <div class="col-md-6">
                              <img  src="img/filter_out.png"  alt="filter out">
                              <p class="text-center"> The Filter Output Signal</p>
                          </div>
                          <div class="col-md-6">
                              <img  src="img/filter_fft.png"  alt="filter fft out">
                              <p class="text-center"> The Filter Output FFT</p>
                          </div>
                      </div>
                      
                      
                <h3>Controls: Keypad and Switches</h3>
                  <p class="lead">
                      The keypad, which is for the user to input tempo, has four row pins and three column pins. 
                      When a button is pressed it closes a switch between the pins corresponding to the column and row that the pressed button is in. 
                      We used the port expander on the board to interface with the keypad, and used the SPI bus to read from and write to the GPIO pins in port Y. 
                      We connected the three column pins to GPIO pins Y4 - Y6, and the four row pins through 330Ω resistors to GPIO pins Y0 - Y3.
                      Pins Y0-Y3 are configured as outputs, while pins Y4-Y6 are configured as inputs with pullup resistors.
                  </p>
                  <img src="img/keypad_sch.png"  alt="keypad circuit">
                  <p class="text-center"> The Keypad Configuration</p>
                  <p class="lead">
                      The switch is a simple toggle switch for the user to turn record mode on and off. 
                      The schematic for this simple circuit is shown below.
                      One side of the switch is connected to power and the other to ground, while the middle pin, the output pin, is connected through a 330Ω resistor to a GPIO pin on the port expander. 
                      The pin will then simply read 1 or 0 depending on which way the switch is flipped.
                  </p>
                  <img src="img/switch_sch.png" alt="switch circuit">
                  <p class="text-center"> The Switch Circuit</p>
              
                <h3>Metronome: LED Response</h3>
                  <p class="lead">
                      The purpose of the LED is to blink at the set tempo when in record mode. 
                      This acts as a metronome to the user, who is presumably playing an instrument. 
                      The user can look at the LED when playing their instrument to determine whether they are rushing or dragging. 
                      Surprisingly, this feature was pivotal to the design because if the user started to rush or drag, the 
                      notes would get interpreted to be the wrong lengths/ occur at the wrong times. 
                      The LED circuit is simple, involving one pin to ground and one to the PIC via a 330 ohm resistor.
                  </p> 
                  <img src="img/led_sch.png"  alt="led circuit">
                  <p class="text-center"> The LED Circuit</p>

                <h3>Communication: Serial Wiring</h3>
                  <p class="lead">
                      The UART serial interface for this lab involved connecting a computer to the PIC using USB, in order to send over data for MIDI file generation. 
                      On the computer side, the connection was as simple as plugging in a USB; the rest of the setup was done in software.  
                      On the PIC side, we connected the 3 of the 4 wires from the serial-USB cable, avoiding the use of the USB +5V red wire. 
                      We connected UART receive pin (U2RX) to the green wire on the cable, UART Transmit (U2TX) to the white wire, and MCU ground to the black wire. 
                      The connector is shown in the following image.  </p>
                      <img src="img/blue_usb.png"  alt="Blue wire thing from Adafruit">
                      <p class="text-center"> The Adafruit USB to TTL Serial Cable</p>

                <h3>Project Casing: ECEs Learn to CAD</h3>
                  <p class="lead">
                      We decided to CAD and laser-cut a box to make our project more presentable. 
                      The CAD was completed using Autodesk Fusion 360. 
                      The box was designed to expose the user only to the TFT screen, the record switch, the LED, the microphone, and the keypad.
                      The dimensions were 22cm x 15cm x 10cm.
                      The box was laser-cut in the Cornell Rapid Prototyping Lab (RPL). 
                      The box was cut from scrap red acrylic found in the RPL.
                  </p> 
                  <img src="img/box_cad.png"  alt="CAD for the box">
                  <p class="text-center"> CAD for the Box Design</p>

                <h3>Hardware: Closing Thoughts</h3>
                  <p class="lead">
                      Overall, the hardware implementation was fairly straightforward. 
                      Future improvements could include increasing the gain on the amplifier. 
                      Increasing the gain would allow people to play their instruments quietly, or further away from the box. 
                      However, this would come at the cost of picking up undesired noise, such as people talking. 
                      <br><br>
                      Additionally, when the box was laser-cut, the hole designated for the microphone was slightly too small. 
                      We eventually filed away some acrylic to allow the microphone to fit. 
                      If this box were to be printed in the future, the microphone hole size should be increased.
                  </p>  
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ Hardware End /-->

  <!--/ Software Start /-->
  <section id="Software" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Software
            </h3>
            <p class="subtitle-a">
              The code behind it all.
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                <h3>Software: Overview </h3>
                  <p class="lead">
                      Our software components involved both a ProtoThreads C implementation running on the PIC32, as well as a Python script running on an external computer. 
                      In the C code, we had an FFT function implementation, which an FFT thread would call. 
                      That thread found the peak frequency from the FFT, calculated MIDI number and octave. 
                      A metronome thread toggled an LED at a user-input tempo, thanks to a variable yield time, and a timer thread running every 1ms updated tft screen transitioning in and out of “record” mode, 
                      displayed the note currently being played to the TFT screen, and sent serial note information to the external computer. 
                      Additionally, we included a keypad thread which read input from the keypad, handled some locking, in addition to other user inputs. 
                      The main C function set up all of these threads and displayed an intro screen welcoming the user to PICcompose. 
                      On the Python side, the serial data sent over from the PIC is converted to MIDI messages and saved to a file. 
                      Finally, a subprocess call is made to open up MuseScore where the recorded MIDI file can be displayed!
                  </p> 
                <h3>Audio Processing: FFT and Note Detection</h3>
                  <p class="lead">
                      In order to interpret the notes in our audio data, we ran an FFT on the data coming into the ADC from the microphone circuit. 
                      Our FFT code was adapted from sample code on the ECE 4760 website. 
                      We used the same function and FFT thread, but changed the resolution of the FFT from a 512-point to a 1024-point FFT in order to more accurately distinguish between notes in our frequency range of interest. 
                      Above middle C (C4), adjacent notes are at least 16Hz apart, and in the main range of a flute the difference between notes is more than that. 
                      With an 8kHz sampling rate, a 1024-point FFT gives us a resolution of about 8Hz, which allows us to tell apart the notes we care about. 
                      To avoid high-frequency aliasing caused by the start and stop of the FFT sampling, a ramp function was used. 
                      Essentially, this ramp cut the beginning and end components of the FFT sample. <br><br>
                      In the FFT thread, we added calculations to determine the highest-amplitude frequency and convert it into a note MIDI number. 
                      To do this we simply added to a pre-existing loop that iterates through the FFT bins, comparing the amplitudes and saving both amplitude and frequency of any bin with a higher amplitude than the previously saved highest amplitude. 
                      The frequency is calculated by multiplying the bin width (in our case, 8Hz) by the bin number. 
                      Due to the presence of some large low-frequency components, we ignore the first 15 bins, giving us a frequency detection threshold of 117Hz.
                      Once we know the strongest frequency present in the FFT, we convert the frequency to its MIDI number using the following equation, where m is the MIDI number and fm is the note frequency: 
                  </p> 
                  <img src="img/midi_eqn.PNG"  alt="MIDI number equation">
                  <p class="lead">
                      This MIDI number is saved as the current MIDI note (the note from the most recent run of the FFT), and used later in the serial communication. 
                      We also calculate which octave the note is in from its MIDI number, which is used when we display the note name to the TFT screen.
                  </p>
    
                <h3>Audio Processing: Metronome and Timing Threads</h3>
                  <p class="lead">
                      An entire thread was dedicated to the metronome aspect of record mode. 
                      The metronome thread was responsible for blinking the LED at the user-set tempo. 
                      To implement this, the frequency of the metronome was changed every time the tempo was set. 
                      During this thread, the LED would toggle. By using the bpm to determine the thread’s yield time, 
                      we were able to coordinate the tempo to the frequency at which the thread runs and 
                      therefore the frequency at which the LED toggles. <br><br>
                      The timing thread was primarily responsible for sending the MIDI numbers, via serial communication, 
                      to the external computer. 
                      This thread runs every millisecond, and revolves around whether the system is in record mode. 
                      While in record mode, whenever a note starts or stops, this thread sends a serial message over 
                      UART to the listening Python script containing the note’s MIDI number and the millisecond time stamp. 
                      It does so by saving the previous note’s MIDI number as well as the current one and comparing these 
                      to each other as well as the “zero” frequency, which is the frequency registered by the FFT 
                      when no note is being played. 
                      The UART messages are sent by spawning the thread <code>PT_DMA_PutSerialBuffer</code>. 
                      The thread increments the recording time each time the thread executes in record mode. 
                      This thread also prints the name of the note being played to the TFT display, 
                      both in record mode and out, and re-prints the whole TFT display when the system transitions into and out of record mode.

                  </p> 

                <h3>Serial: Python and MIDI</h3>
                  <p class="lead">
                      We used a Python script in order to generate the actual MIDI files by listening for serial inputs, primarily using a library called mido for MIDI parsing and the pySerial library to read in the serial stream. 
                      The first thing the script does is initialize a <code>MidiFIle</code> object and fill it with the default data (common between all MIDI files) 
                      and establish a serial connection by listening at the 38400 baud rate. 
                      On the computer end, that connection involved downloading the Prolific drivers for the UART cable, which can be found 
                      <a style="color:rgb(107, 102, 102)" href="http://www.prolific.com.tw/US/ShowProduct.aspx?p_id=229&pcid=41"><strong>here</strong></a>
                      for macOS.  A few default global values are also set, such as a serial timeout length, 
                      whether or not the system was in record mode, and some tempo-related data. 
                      From here, an infinite while loop was used to process the serial stream. When a command is sent over by the PIC, 
                      the script splits the message using spaces as delimiters and saves it in a message array. 
                      The loop then goes through a series of cases depending on what is contained in the message. <br>
                      <br><br>The five valid serial messages begin with “BPM”, “BEGIN”, “START”, “STOP”, and “END”. 
                      “BPM” was used to set the tempo, “BEGIN” and “END” were used to define the recording interval, 
                      and “START” and “STOP” were used for individual note length and value determination. 
                      If the message contains “BPM”, the next value in the array is assumed to be a tempo in beats per minute 
                      that the user input from the keypad. 
                      That value was saved as a global variable, which all note length calculations used, and also written to the <code>MidiFile</code> object.
                      If the script received a message with “BEGIN” in it, the system was put into record mode by setting the 
                      recording global variable to <code>True</code>.<br><br>
                      The “START” and “STOP” messages performed similar functions by writing MIDI bytes to the <code>MidiFile</code> object 
                      corresponding to when a note started and stopped. 
                      In the split array, following the “START” or “STOP” keywords, two pieces of information were sent over by the PIC: 
                      MIDI note and global time in milliseconds. 
                      When writing out the command in MIDI bytes, four numbers are required (delta time, MIDI message type, note number, velocity). 
                      We could directly use the note number, and a default value for velocity, and the same MIDI message type for all notes (<code>note_on</code>). 
                      However, we needed to perform some additional processing to get the delta time value required. 
                      MIDI records global time using microseconds, or “ticks.” and the PPQ (ticks per quarter note) 
                      is stored as a default (480) for MIDI tracks created with mido. 
                      Both “START” and “STOP” messages required a delta time (that’s how rests are encoded), so we could calculate them similarly 
                      using the following formula:
                      <br>
                  </p><p class="lead" style="text-align:center;">tick_diff = (start ms - last ms) * (1min / 60000ms) * (ticks/qn * qn/min) </p>
                  <p class="lead">
                      Essentially, we found the difference in milliseconds between the current note and the last note, 
                      converted that time to minutes, and then used the BPM (qn/min) and PPQ (ticks/qn) to get the note length in ticks, 
                      and wrote that number to the <code>MidiFile</code> object. 
                      Unfortunately, this system turned out to be too accurate, and resulted in random rests 
                      and note blips of sixteenth note value or less. To mitigate this, we reduced our “resolution” to quarter note lengths, 
                      i.e. the shortest note length possible was a quarter note. 
                      Messages sent with calculated delta time values of less than half a quarter note were ignored, 
                      everything else was “snapped” to a quarter note length using integer division and rounding. 
                      Apart from note length determination, some additional filtering (such as removing consecutive notes with an octave or 
                      more of a difference) was done in the loop.
                      <br><br>
                      Finally, when the script received an “END” message, the recording global variable was set to <code>False</code>, 
                      and the <code>MidiFile</code> object was saved to a .mid file with the name “recording”+the current date and time in ISO format. 
                      The Python script then triggered a subprocess call that would open up the MuseScore application on the computer, 
                      where a user could open up the created MIDI file. 
                      Once the MuseScore application was closed, the loop could be restarted with the defaults reset, 
                      in order to make a new recording.
                  </p> 

                <h3>Controls: User Interface</h3>
                  <p class="lead">
                    The user interface involved a series of panels drawn using the functions from the TFT library. 
                    The first pane is an intro screen only displayed once, when the system is first powered on. 
                    The text is displayed using the <code>printline()</code> functions and the eight note was drawn using the 
                    <code>tft_drawLine()</code> and <code>tft_fillCircle()</code> functions.
                    The following two panes are displayed to the user during the tempo input mode, and change based on button presses. 
                    The first of the two is displayed as a user is inputting tempo, and the later one is displayed when the # key is pressed to "lock" the tempo input. The user prompts at the bottom change as well.
                    <code>tft_fillRoundRect()</code> functions are used to change displays, such as the note played at the time.
                    The final pane is switched to when the record switch on the front of the box is switched; switching it back returns the user to the tempo input screen. 
                    The main differences from the previous two panes, besides the color, are the user prompts at the bottom and the size of the tempo/note being displayed.
                    Both modes allow you to see both pieces of information, but one is more important than the other depending on the current mode.
                    All four panes are shown below: <br><br>
                  </p>
                  <div class="row">
                    <div class="col-md-3">
                        <img height=175 width=225 src="img/intro_screen.jpg"  alt="intro screen">
                        <p style="font-size: larger; text-align: center;">Intro Screen</p>
                    </div>
                    <div class="col-md-3">
                        <img height=175 width=225 src="img/tempo.jpg"  alt="tempo screen">
                        <p style="font-size: larger; text-align: center;">Tempo Set Screen</p>
                    </div>
                    <div class="col-md-3">
                        <img height=175 width=225 src="img/set_tempo.jpg"  alt="set tempo screen">
                        <p style="font-size: larger; text-align: center;">Tempo Locked Screen</p>
                    </div>
                    <div class="col-md-3">
                        <img height=175 width=225 src="img/record.jpg"  alt="record screen">
                        <p style="font-size: larger; text-align: center;">Record Screen</p>
                    </div>
                  </div>
                <h3>Controls: Keypad and Switches</h3>
                  <p class="lead">
                      The purpose of the keypad is to take user input to leave the start-up screen, and to take user input for setting the tempo. 
                      A keypad thread was written to implement this functionality, and starts with a finite state machine that debounces key presses. 
                      Keys are debounced to prevent a single key press from getting interpreted as multiple key presses. 
                      After the keys are debounced, this thread interprets what key was pressed, and what action to take accordingly. 
                      If the user is in tempo input mode and the tempo has not been entered (via the press of the # button), 
                      this thread displays the key pressed on the TFT display in green. 
                      This thread blocks users from entering tempos that are over three digits long. 
                      If a user attempts to continue entering digits beyond three, these digits do not appear on the TFT display. 
                      <br><br>
                      Once a user has entered their desired tempo, they press the # button. 
                      The tempo is then locked, and further key presses are ignored unless the * button is pressed. 
                      The * button allows users to clear and reset the tempo. <br><br>
                      The purpose of the switch was to switch between tempo input mode and record mode. 
                      When the switch is flipped from tempo input mode to record mode, the LED begins blinking and the Python script 
                      begins listening for messages. 
                      If a tempo has been set by the user, the recording tempo is that user-set tempo. 
                      If the user did not enter a tempo, the recording tempo defaults to 120 BPM.<br><br>
                      When the switch is flipped from record mode to tempo input mode, the previous tempo is cleared. 
                      The user can then set a new tempo for the next recording. 
                   </p>

                <h3>Software: Closing Thoughts</h3>
                  <p class="lead">
                      As a whole we ran into little trouble implementing our full software structure and thread organization to execute the tasks we desired. 
                      Although the FFT is computationally expensive, the complexity and computation time of our other threads was relatively low, which allowed everything to function smoothly from the user interface perspective with no noticeable delays in the timer and metronome threads. 
                      We also did not run into any problems with running out of memory on the PIC32, despite the fact that increasing the FFT resolution used a lot more memory. 
                      In addition, the python script interacted well with the UART serial interface. 
                      The most tedious part of the software was designing the user interface, as it required us to meticulously plan out where everything should be drawn on the screen.      
                  </p>  
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ Software End /-->

  <!--/ Results Start /-->
  <section id="Results" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Results
            </h3>
            <p class="subtitle-a">
              It worked!
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                  <p class="lead">
                      The execution speed for both the note detection and serial communication were fast enough for our project that the execution was not hindered. 
                      The only noticeable latency is immediately between when a user plays a note, and the first time that note is displayed. 
                      The FFT does take some time to execute, but users get feedback as soon as possible. 
                      On the notation end, fully real-time generation of sheet music was non-essential for our design; the annotated score pops up at the end for a user to evaluate.
                      You can see our project in action here: </p>
                      <p><iframe  width="420" height="315"  src="https://www.youtube.com/embed/7qzfAA90V8g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
                      <p class="text-center"> Our YouTube demo!</p>
                      <br>
                      <p class="lead">
                      As can be seen in our demo video, we are able to notate simple melodies, such as Twinkle Twinkle Little Star, 
                      with 100% accuracy in both note detection as well as note lengths. 
                      Our note resolution in the flute’s octave range is also error-free for a short chromatic scale. 
                      Screenshots from our notated scores are shown below: </p>
                      <img  src="img/chromatic.png"  alt="chromatic scale">
                      <p class="text-center"> A Short Chromatic Scale</p>
                      <img  src="img/ttls.png"  alt="filter fft out">
                      <p class="text-center"> Twinkle Twinkle Little Star</p>
                      <p class="lead">
                      These were recorded at two different tempos in our demo, with no change to accuracy. 
                      We anticipate our notation accuracy will decrease with more complex music, but have not verified this yet. 
                      However, since the score is editable, even if there are errors in it a user can go in and correct them using their notation software and save an updated copy. 
                      But, more robust testing of the product will definitely be required, especially if we want to develop this further.
                      <br><br>
                      We enforced safety in the design by encapsulating our electronic components in a box. The box prevents a user from poking around and potentially get shocked by any of our circuitry. 
                      Our project did not cause or experience interference from other people’s designs. 
                  </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ Results End /-->
      

  <!--/ Conclusions Start /-->
  <section id="Conclusions" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Conclusions
            </h3>
            <p class="subtitle-a">
              Our final thoughts.
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                  <p class="lead">
                      Our project met most of our expectations. 
                      We expected our project to take audio from a user and notate that audio. 
                      We could successfully demonstrate this. 
                      The only expectation that we did not meet was the notation of notes shorter than a quarter note. 
                      When we initially tested our project, we discovered that our project was too accurate in that it could pick up and notate artifacts caused by tonguing, vibrato, note decay, etc. 
                      We could see this affect our score; undesired 32nd and 64th notes would appear that notated our every user inaccuracy. 
                      To resolve this issue, we chose to decrease the note length resolution in the Python script.
                      A note would only be notated as a quarter note if that note were detected for over half the quarter length period, 
                      as designated by the tempo. With this fix, our accuracy was immensely improved.
                      <br><br>
                      With that being said, we could further improve this project by modifying how we resolve our notes. 
                      Currently, our project only supports quarter note level resolution so the shortest note we can notate is a quarter note. 
                      However, we can resolve quarter notes at very fast tempos. 
                      An eighth note at 60 BPM is the same as quarter note at 120 BPM, and we are able resolve quarter notes at both tempos. 
                      Because of this, we believe that with some changes in how note resolution is calculated and further fine-tuning in the code, 
                      we could visually increase our scope to faster notes.
                      <br><br>
                      Another design improvement would be to implement a Bluetooth connection. 
                      While there was nothing inherently wrong with using a serial interface, 
                      a Bluetooth connection would provide a user with more convenience. 
                      The use would be able to pick up our project and place it in different locations without carrying a laptop with them. 
                      <br><br>
                      One great aspect of our project is that it conforms to the universal standard of MIDI. 
                      MIDI files may be opened in almost all available score-editing softwares. 
                      We opened our scores in MuseScore3, however a user could choose to open their scores in other software such as Sibelius or Finale. 
                      <br><br>
                      There are potentially publication or patent opportunities associated with this project. 
                      Automatic sheet music generators exist, but they are very few in number. 
                      Some popular implementations include 
                      <a  href="https://www.lunaverus.com/">AnthemScore, </a>
                      <a  href="https://scorecloud.com/">ScoreCloud,  </a> and 
                      <a  href="https://melodyscanner.com/">Melody Scanner.</a> 
                      However, our project is distinct from them in two major ways. 
                      First, since we are working with a PIC32 microcontroller, <strong><u>our project is a software-hardware hybrid implementation.</u></strong>
                      Other sheet music generators are a pure software implementation. 
                      Because of that, those products support robust calculations including some machine learning tactics. 
                      Our only uses a software implementation of an FFT, making it much faster and executable in an embedded environment.
                      Given that it includes hardware in its implementation, PICcompose only needs to be purchased once (if productized). 
                      The other products are typically subscription based, making them financially inaccessible to some people. 
                      The second major difference is that our project is <strong><u>cross-platform compatible,</u></strong> thanks to the MIDI format we export. 
                      The other products typically have a sheet music editor built into their software. 
                      Ours can be used directly with pre-existing notation softwares such as MuseScore and Finale, 
                      meaning that a composer could use our product without changing their workflow. 
                      These aspects of our project are relatively novel, and possibly patent-worthy with further development.
                      <br><br>
                      During the design, construction, and use of this project, we abided by the IEEE Code of Ethics. 
                      We also did not have any safety concerns or legal considerations throughout the process. 
                      <br><br>
                    <p class="text-center" style="font-size:larger;"> Overall, we loved this project and had a great time working on it together! Stay tuned for updates if we continue development work :)</p>
                    <img height=500 width=750  src="img/group_pic.jpg"  alt="Tara jumps lol">
                  </p>

            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <!--/ Conclusions End /-->

  <!--/ Appendix Start /-->
  <section id="Appendix" class="services-mf route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Appendix
            </h3>
            <p class="subtitle-a">
              Additional Data.
            </p>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="container">
          <div class="col-sm-12">
            <div class="box-shadow-full">
                <h4 >Appendix A: Project Inclusion</h4>
                  <p class="lead">
                    <em>The group approves this report for inclusion on the course website.</em><br>
                    <em>The group approves the video for inclusion on the course YouTube channel.</em>
                  </p>
                <h4>Appendix B: Schematics</h4>
                  <p class="lead">
                      The following are schematics of the circuitry for each of our main hardware components and how they are connected to the microcontroller board.
                      <div class="row">
                          <div class="col-md-8">
                              <img style="height: 50%; width: 50%" src="img/sallenkey.png"  alt="microphone schematic">
                              <p class="text-center"> Microphone Circuit</p>
                          </div>
                          <div class="col-md-4">
                              <img src="img/led_sch.png"  alt="led circuit">
                              <p class="text-center"> LED Circuit</p>
                          </div>
                      </div>
                      <div class="row">
                          <div class="col-md-6">
                              <img src="img/keypad_sch.png"  alt="keypad circuit">
                              <p class="text-center"> Keypad Circuit</p>
                          </div>
                          <div class="col-md-6">
                              <img src="img/switch_sch.png" alt="switch circuit">
                              <p class="text-center"> Switch Circuit</p>
                          </div>
                      </div>
                  </p>
                <h4>Appendix C: Budget</h4>
                  <img height=600 width=950 src="img/budget.png"  alt="budget table">
                  <p style="font-size: larger; text-align: center;">Budget Table</p>
                <h4>Appendix D: Work Distribution</h4>
                  <div class="row" style="text-align:center;">
                    <div class="col-md-4">
                        <img height=304 width=257 src="img/diane.png"  alt="Diane">
                        <p class="lead" style="text-align: center; font-size: x-large;"><strong>Diane</strong></p>
                        <ul style="text-align: left;">
                            <li>Constructed hardware amplifier and filter</li>
                            <li>Design the box CAD and oversaw the laser-cutting</li>
                            <li>Configured the physical user interface (with keypad, toggle switch, and LED)</li>
                            <li>Helped design the PIC-side MIDI message serial interface</li>
                            <li>Improved audio filtering in software</li>
                            <li>Wrote the final report</li>
                          </ul>
                    </div>
                    <div class="col-md-4">
                        <img height=304 width=257 src="img/laas.png"  alt="Laasya">
                        <p class="lead" style="text-align: center; font-size: x-large;"><strong>Laasya</strong></p>
                        <ul style="text-align: left;">
                          <li>Adapted FFT code from DSP page to project's use case</li>
                          <li>Decoded the full MIDI protocol and investigated Python libraries</li>
                          <li>Built Python script to receive serial input from PIC, and save to file</li>
                          <li>Storyboarded UI design and assisted with hardware casing design</li>
                          <li>Configured website UI layout</li>
                          <li>Wrote the final report</li>
                        </ul>
                    </div>
                    <div class="col-md-4">
                        <img height=304 width=257 src="img/tara.png"  alt="Tara">
                        <p class="lead" style="text-align: center; font-size: x-large;"><strong>Tara</strong></p>
                        <ul style="text-align: left;">
                            <li>Assisted in designing and testing microphone circuitry</li>
                            <li>Adapted sample FFT code and note-decoding calculations</li>
                            <li>Implemented timing and protocol of serial communication messages</li>
                            <li>Helped design and implement the final display user interface</li>
                            <li>Set everything up inside the box</li>
                            <li>Composed the budget</li>
                            <li>Wrote the final report</li>
                          </ul>
                    </div>
                  </div>
                  <br>
                <h4>Appendix E: References </h4>
                  <div class="row" style="text-align:center;">
                    <div class="col-md-3">
                      <h5>Data Sheets</h5>
                        <ul class="list-unstyled">
                          <li><a style="color: #be0b0b;" href="https://www.electronics-tutorials.ws/filter/sallen-key-filter.html">Sallen Key</a></li>
                          <li><a style="color: #be0b0b;" href="http://sim.okawa-denshi.jp/en/OPstool.php">Sallen Key Calculator</a></li>
                          
                        </ul> 
                    </div>
                    <div class="col-md-3">
                        <h5>Vendor Sites</h5>
                        <ul class="list-unstyled">
                          <li><a style="color: #be0b0b;" href="https://www.adafruit.com/product/1480">TFT Display</a></li>
                          <li><a style="color: #be0b0b;" href="https://www.adafruit.com/product/1064">Electret Mic</a></li>
                          <li><a style="color: #be0b0b;" href="https://www.onsemi.com/pub/Collateral/LF353-D.pdf">Audio Amp</a></li>
                        </ul> 
                    </div>
                    <div class="col-md-3">
                        <h5>Background Sites</h5>
                        <ul class="list-unstyled">
                          <li><a style="color: #be0b0b;" href="https://www.csie.ntu.edu.tw/~r92092/ref/midi/">Midi Protocol</a></li>
                          <li><a style="color: #be0b0b;" href="https://mido.readthedocs.io/en/latest/index.html">Mido Library Reference</a></li>
                        </ul> 
                    </div>
                    <div class="col-md-3">
                        <h5>Design References</h5>
                        <ul class="list-unstyled">
                          <li><a style="color: #be0b0b;" href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/target_board.html">SECABB Board</a></li>
                          <li><a style="color: #be0b0b;" href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_TFT_display.html">TFT, </a>
                              <a style="color: #be0b0b;" href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_DSP.html">FFT, </a>
                              <a style="color: #be0b0b;" href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">Serial, </a>
                          </li> 
                          <li><a style="color: #be0b0b;" href="http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/f2016/wm226_hd294/wm226_hd294/wm226_hd294/index.html">F16 Electronic Tuner</a></li>
                          <li><a style="color: #be0b0b;" href="https://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/s2011/sap76_rns49/index.html">S11 Music Notator</a></li>
                        </ul> 
                        <br>
                    </div>
                    </div>
                <h4>Appendix F: Python Serial to MIDI Code</h4><div>
                  <script slice=0:50 style="text-align: left;" src="http://gist-it.appspot.com/https://github.com/laasya98/PICCompose/blob/master/make_midi.py"></script>
                </div>
                <div>
                  <span><h4>Appendix G: Main PIC Code</h4></span>
                  <script width=70% src="http://gist-it.appspot.com/https://github.com/laasya98/PICCompose/blob/master/main.c"></script>
                </div>
            </div>
          </div>
        </div>
    </div>
  </section>
  <!--/ Appendix End /-->
  <a href="#" class="back-to-top"><i class="fa fa-chevron-up"></i></a>
  <div id="preloader"></div>

  <!-- JavaScript Libraries -->
  <script src="lib/jquery/jquery.min.js"></script>
  <script src="lib/jquery/jquery-migrate.min.js"></script>
  <script src="lib/popper/popper.min.js"></script>
  <script src="lib/bootstrap/js/bootstrap.min.js"></script>
  <script src="lib/easing/easing.min.js"></script>
  <script src="lib/counterup/jquery.waypoints.min.js"></script>
  <script src="lib/counterup/jquery.counterup.js"></script>
  <script src="lib/owlcarousel/owl.carousel.min.js"></script>
  <script src="lib/lightbox/js/lightbox.min.js"></script>
  <script src="lib/typed/typed.min.js"></script>
  <!-- Contact Form JavaScript File -->
  <script src="contactform/contactform.js"></script>

  <!-- Template Main Javascript File -->
  <script src="js/main.js"></script>

</body>
</html>
